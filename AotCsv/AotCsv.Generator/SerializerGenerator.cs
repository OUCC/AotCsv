using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Oucc.AotCsv.Generator.Comparer;
using Oucc.AotCsv.Generator.Utility;

namespace Oucc.AotCsv.Generator;

[Generator(LanguageNames.CSharp)]
public class SerializerGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var attributeContext = context.SyntaxProvider.ForAttributeWithMetadataName(
            "Oucc.AotCsv.Attributes.CsvSerializableAttribute",
            static (_, _) => true,
            static (context, _) => context);

        var source = attributeContext.Combine(context.CompilationProvider).WithComparer(GeneratorComparer.Instance);

        context.RegisterSourceOutput(source, static (context, source) =>
        {
            var (attributeContext, compilation) = source;

            Emit(context, attributeContext, compilation);
        });
    }

    private static void Emit(SourceProductionContext context, GeneratorAttributeSyntaxContext source, Compilation compilation)
    {
        var targetSymbol = (INamedTypeSymbol)source.TargetSymbol;
        var targetTypeName = targetSymbol.Name;

        var builder = new StringBuilder();
        var reference = new ReferenceSymbols(compilation);
        var targets = GetTargetMembers(targetSymbol, reference);

        builder.Append("""
            // <auto-generated/>

            """);

        if (!targetSymbol.ContainingNamespace.IsGlobalNamespace)
            builder.AppendFormatted($"namespace {targetSymbol.ContainingNamespace.ToString()};\n");

        builder.AppendFormatted($$"""

            partial {{(targetSymbol.IsRecord ? "record " : "")}}{{(targetSymbol.TypeKind == TypeKind.Class ? "class" : "struct")}} {{targetTypeName}} : global::Oucc.AotCsv.ICsvSerializable<{{targetTypeName}}>
            {
                static void global::Oucc.AotCsv.ICsvSerializable<{{targetTypeName}}>.WriteHeader(global::System.IO.TextWriter writer, global::Oucc.AotCsv.CsvSerializeConfig context)
                {

            """);

        SerializeCodeGenerator.CreateHeaderCode(targets, builder);

        builder.AppendFormatted($$"""
                }

                static void global::Oucc.AotCsv.ICsvSerializable<{{targetTypeName}}>.WriteRecord(global::System.IO.TextWriter writer, global::Oucc.AotCsv.CsvSerializeConfig config, {{targetTypeName}} value)
                {
            """);

        SerializeCodeGenerator.CreateBodyCode(builder, targets, reference);

        builder.Append("""
                }

           """);

        DeserializeCodeGenerator.WriteHeaderCode(builder,targets, targetTypeName);

        DeserializeCodeGenerator.WriteBodyCode(builder, targets, targetSymbol, reference);

        builder.Append("}\n");
        var result = builder.ToString();

        context.AddSource(targetTypeName + ".g.cs", builder.ToString());
    }


    private static MemberMeta[] GetTargetMembers(INamedTypeSymbol targetSymbol, ReferenceSymbols reference)
    {
        var result = targetSymbol.GetMembers()
            .Select(MemberMeta (m) =>
            {
                // Whereで nullreference type を絞れないため!をつける
                if (m is IPropertySymbol p)
                    return IsTargetProperty(p, reference) ? new MemberMeta(p) : null!;
                if (m is IFieldSymbol f)
                    return IsTargetField(f, reference) ? new MemberMeta(f) : null!;
                return null!;
            })
            .Where(m => m is not null)
            .OrderBy(m => m.Index ?? uint.MaxValue)
            .ToArray();
        return result;
    }

    private static bool IsTargetProperty(IPropertySymbol property, ReferenceSymbols reference)
    {
        return
            // 必須条件
            !property.IsStatic && !property.IsWriteOnly && !property.IsIndexer && IsTargetType(property.Type, reference)
            && property.GetAttributes().All(a => !reference.CsvIgnoreAttribute.Equals(a.AttributeClass, SymbolEqualityComparer.Default))
            // デフォルトの条件
            && (property.DeclaredAccessibility == Accessibility.Public && !property.IsReadOnly
                // 属性がついていたとき
                || property.GetAttributes().Any(a => reference.CsvIncludeAttribute.Equals(a.AttributeClass, SymbolEqualityComparer.Default)));
    }


    private static bool IsTargetField(IFieldSymbol field, ReferenceSymbols reference)
    {
        return
            // 必須条件
            !field.IsStatic && IsTargetType(field.Type, reference)
            && field.GetAttributes().All(a => !reference.CsvIgnoreAttribute.Equals(a.AttributeClass, SymbolEqualityComparer.Default))
            // デフォルトの条件
            && (field.DeclaredAccessibility == Accessibility.Public && !field.IsReadOnly
                // 属性がついていたとき
                || field.GetAttributes().Any(a => reference.CsvIncludeAttribute.Equals(a.AttributeClass, SymbolEqualityComparer.Default)));
    }

    private static bool IsTargetType(ITypeSymbol type, ReferenceSymbols reference)
    {
        if (type.NullableAnnotation == NullableAnnotation.Annotated && type.IsValueType)
        {
            var typeArgument = (type as INamedTypeSymbol)!.TypeArguments[0];
            return typeArgument.AllInterfaces.Contains(reference.ISpanFormattable)
                || typeArgument.Equals(reference.Boolean, SymbolEqualityComparer.Default);// boolのAnnotatedはここで拾う
        }
        else
        {
            return type.AllInterfaces.Contains(reference.ISpanFormattable)
                || type.Equals(reference.String, SymbolEqualityComparer.Default)
                || type.Equals(reference.Boolean, SymbolEqualityComparer.Default);// boolのNotAnnotatedはここで拾える
        }
    }
}
