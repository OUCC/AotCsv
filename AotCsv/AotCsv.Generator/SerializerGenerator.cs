using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Oucc.AotCsv.Generator.Comparer;
using Oucc.AotCsv.Generator.Utility;

namespace Oucc.AotCsv.Generator;

[Generator(LanguageNames.CSharp)]
public class SerializerGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var attributeContext = context.SyntaxProvider.ForAttributeWithMetadataName(
            "Oucc.AotCsv.Attributes.CsvSerializableAttribute",
            static (_, _) => true,
            static (context, _) => context);

        var source = attributeContext.Combine(context.CompilationProvider).WithComparer(GeneratorComparer.Instance);

        context.RegisterSourceOutput(source, static (context, source) =>
        {
            var (attributeContext, compilation) = source;

            Emit(context, attributeContext, compilation);
        });
    }

    private static void Emit(SourceProductionContext context, GeneratorAttributeSyntaxContext source, Compilation compilation)
    {
        var cancellationToken = context.CancellationToken;
        cancellationToken.ThrowIfCancellationRequested();

        var targetSymbol = (INamedTypeSymbol)source.TargetSymbol;
        var targetTypeName = targetSymbol.ToDisplayString(SymbolFormat.NameOnly);

        var builder = new StringBuilder();
        var reference = new ReferenceSymbols(compilation);
        var targets = GetTargetMembers(targetSymbol, reference, cancellationToken);
        var containingTypes = GetTargetSymbolContainingTypes(targetSymbol, cancellationToken);
        var helperClassName = targetSymbol.Arity == 0
            ? string.Concat(targetSymbol.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), ".Helper")
            : string.Concat(targetSymbol.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), ".Helper<", string.Join(", ", targetSymbol.TypeParameters.Select(t => t.ToDisplayString(SymbolFormat.NameOnly))), ">");

        cancellationToken.ThrowIfCancellationRequested();
        builder.Append("""
            // <auto-generated/>
            #nullable enable

            """);

        if (!targetSymbol.ContainingNamespace.IsGlobalNamespace)
            builder.AppendFormatted($"namespace {targetSymbol.ContainingNamespace.ToString()};\n");

        foreach (var containingType in containingTypes)
        {
            builder.AppendFormatted($$"""

                partial {{(containingType.IsRecord ? "record " : "")}}{{(containingType.TypeKind == TypeKind.Class ? "class" : "struct")}} {{containingType.ToDisplayString(SymbolFormat.NameOnly)}} {
                """);
        }

        builder.AppendFormatted($$"""

            partial {{(targetSymbol.IsRecord ? "record " : "")}}{{(targetSymbol.TypeKind == TypeKind.Class ? "class" : "struct")}} {{targetTypeName}} : global::Oucc.AotCsv.ICsvSerializable<{{targetTypeName}}>
            {
                static void global::Oucc.AotCsv.ICsvSerializable<{{targetTypeName}}>.WriteHeader(global::System.IO.TextWriter writer, global::Oucc.AotCsv.CsvSerializeConfig context)
                {

            """);

        SerializeCodeGenerator.CreateHeaderCode(targets, builder, cancellationToken);

        builder.AppendFormatted($$"""
                }

                static void global::Oucc.AotCsv.ICsvSerializable<{{targetTypeName}}>.WriteRecord(global::System.IO.TextWriter writer, global::Oucc.AotCsv.CsvSerializeConfig config, {{targetTypeName}} value)
                {
            """);

        SerializeCodeGenerator.CreateBodyCode(builder, targets, reference, cancellationToken);

        builder.Append("""
                }

           """);

        DeserializeCodeGenerator.WriteHeaderCode(builder, targets, targetTypeName, helperClassName, cancellationToken);

        DeserializeCodeGenerator.WriteBodyCode(builder, targets, targetSymbol, reference, helperClassName, cancellationToken);

        for (int i = 0; i < containingTypes.Count + 1; i++)
        {
            builder.Append("}\n");
        }

        WriteMetadata(builder, helperClassName, targetTypeName, targets, cancellationToken);

        builder.Append("#nullable restore\n");
        var result = builder.ToString();

        context.AddSource(targetSymbol.Name + ".g.cs", result);
    }

    private static void WriteMetadata(StringBuilder builder, string className, string targetTypeName, MemberMeta[] members, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        builder.AppendFormatted($$"""
            file static class {{className}}
            {
                public static global::Oucc.AotCsv.MappingMetadata MappingMetadata => new(
                        typeof({{targetTypeName}}),
                        global::System.Collections.Immutable.ImmutableArray.Create<global::Oucc.AotCsv.MemberMetadata>(

            """);


        for (var i = 0; i < members.Length; i++)
        {
            var member = members[i];

            builder.AppendFormatted($$"""
                                new global::Oucc.AotCsv.MemberMetadata({{member.InternalId}}, typeof({{member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}}), @"{{member.Symbol.Name}}", @"{{member.HeaderName}}", {{member.Index}}
                """);
            WriteString(builder, member.Format);
            WriteString(builder, member.DateTimeFormat.Item1);
            builder.AppendFormatted($$"""
                , (global::System.Globalization.DateTimeStyles){{(int)member.DateTimeFormat.Item2}}
                """);
            builder.AppendFormatted($$"""
                , {{(member.State & MemberMeta.MemberState.Property) == MemberMeta.MemberState.Property}}
                """);
            builder.AppendFormatted($$"""
                , {{(member.State & MemberMeta.MemberState.Settable) == MemberMeta.MemberState.Settable}}
                """);
            builder.AppendFormatted($$"""
                , {{(member.State & MemberMeta.MemberState.Readable) == MemberMeta.MemberState.Readable}})
                """);

            if (i < members.Length - 1)
            {
                builder.Append(",\n");
            }
        }


        builder.Append("""
                        )
                    );
            }

            """);

        static void WriteString(StringBuilder builder, string? value)
        {

            if (value is null) builder.Append(", null");
            else
            {
                builder.Append(", @\"");
                builder.Append(value);
                builder.Append('"');
            }
        }
    }

    private static List<ITypeSymbol> GetTargetSymbolContainingTypes(INamedTypeSymbol targetSymbol, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();
        var result = new List<ITypeSymbol>();
        var containingType = targetSymbol.ContainingType;
        while (true)
        {
            if (containingType is null)
            {
                break;
            }
            else
            {
                result.Add(containingType);
            }
            containingType = containingType.ContainingType;
        }
        result.Reverse();
        return result;
    }

    private static MemberMeta[] GetTargetMembers(INamedTypeSymbol targetSymbol, ReferenceSymbols reference, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();
        var result = targetSymbol.GetMembers()
            .Select(MemberMeta (m, i) =>
            {
                // Whereで null reference type を絞れないため!をつける
                if (m is IPropertySymbol p)
                    return IsTargetProperty(p, reference) ? new MemberMeta(i + 1, p) : null!;
                if (m is IFieldSymbol f)
                    return IsTargetField(f, reference) ? new MemberMeta(i + 1, f) : null!;
                return null!;
            })
            .Where(m => m is not null)
            .OrderBy(m => m.Index ?? uint.MaxValue)
            .ToArray();
        return result;
    }

    private static bool IsTargetProperty(IPropertySymbol property, ReferenceSymbols reference)
    {
        return
            // 必須条件
            !property.IsStatic && !property.IsWriteOnly && !property.IsIndexer && IsTargetType(property.Type, reference)
            && property.GetAttributes().All(a => !reference.CsvIgnoreAttribute.Equals(a.AttributeClass, SymbolEqualityComparer.Default))
            // デフォルトの条件
            && (property.DeclaredAccessibility == Accessibility.Public && !property.IsReadOnly
                // 属性がついていたとき
                || property.GetAttributes().Any(a => reference.CsvIncludeAttribute.Equals(a.AttributeClass, SymbolEqualityComparer.Default)));
    }


    private static bool IsTargetField(IFieldSymbol field, ReferenceSymbols reference)
    {
        return
            // 必須条件
            !field.IsStatic && IsTargetType(field.Type, reference)
            && field.GetAttributes().All(a => !reference.CsvIgnoreAttribute.Equals(a.AttributeClass, SymbolEqualityComparer.Default))
            // デフォルトの条件
            && (field.DeclaredAccessibility == Accessibility.Public && !field.IsReadOnly
                // 属性がついていたとき
                || field.GetAttributes().Any(a => reference.CsvIncludeAttribute.Equals(a.AttributeClass, SymbolEqualityComparer.Default)));
    }

    private static bool IsTargetType(ITypeSymbol type, ReferenceSymbols reference)
    {
        if (type.NullableAnnotation == NullableAnnotation.Annotated && type.IsValueType)
        {
            var typeArgument = (type as INamedTypeSymbol)!.TypeArguments[0];
            return typeArgument.AllInterfaces.Contains(reference.ISpanFormattable)
                || typeArgument.Equals(reference.Boolean, SymbolEqualityComparer.Default);// boolのAnnotatedはここで拾う
        }
        else
        {
            return type.AllInterfaces.Contains(reference.ISpanFormattable)
                || type.Equals(reference.String, SymbolEqualityComparer.Default)
                || type.Equals(reference.Boolean, SymbolEqualityComparer.Default);// boolのNotAnnotatedはここで拾える
        }
    }
}
